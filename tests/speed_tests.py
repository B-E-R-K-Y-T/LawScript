import time
from random import randint

from util.build_tools.compile import Compiled
from util.build_tools.starter import compile_string, run_compiled_code

PATH_TO_LIB = "стандартная_библиотека.*"

cases = {
    "Простой тест":
    """
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ ТЕСТ_0() (
        НАПЕЧАТАТЬ "ТЕСТ0";
    )
    ВЫПОЛНИТЬ (
        ТЕСТ_0();
    )
    """,
    "Поиск суммы":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ сум() (
        ЗАДАТЬ результат = 0;
        ЗАДАТЬ массив_чисел = массив({", ".join(map(str, range(100)))});
        ЗАДАТЬ длина = длина_массива(массив_чисел);
        
        ЦИКЛ текущий_индекс ОТ 0 ДО длина-1 (
            результат = (результат + достать_из_массива(массив_чисел, текущий_индекс)) * 2 + 100;
        )
        
        НАПЕЧАТАТЬ результат;
    )
    
    ВЫПОЛНИТЬ (
        сум();
    )
    """,
    "Сортировка массива":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ сортировка_массива(массив_чисел) (
        ЗАДАТЬ длина = длина_массива(массив_чисел);
        ЗАДАТЬ минимальный_индекс = 0;
        
        ЦИКЛ индекс ОТ 0 ДО длина-1 (
            ! Находим минимальный элемент в оставшейся части массива
            минимальный_индекс = индекс;
            
            ЦИКЛ внутренний_индекс ОТ индекс+1 ДО длина-1 (
                ЕСЛИ достать_из_массива(массив_чисел, внутренний_индекс) МЕНЬШЕ достать_из_массива(массив_чисел, минимальный_индекс) ТО (
                    минимальный_индекс = внутренний_индекс;
                )
            )
            
            ! Меняем местами найденный минимальный элемент с текущим
            ЕСЛИ минимальный_индекс НЕРАВНО индекс ТО (
                ЗАДАТЬ временная_переменная = достать_из_массива(массив_чисел, индекс);
                изменить_в_массиве(массив_чисел, индекс, достать_из_массива(массив_чисел, минимальный_индекс));
                изменить_в_массиве(массив_чисел, минимальный_индекс, временная_переменная);
            )
        )
        
        НАПЕЧАТАТЬ массив_чисел;
    )
    
    ВЫПОЛНИТЬ (
        сортировка_массива(массив({", ".join([str(randint(0, 100)) for _ in range(100)])}));
    )
    """,
    "Вызов функций с аргументами по умолчанию":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ по_умолчанию()(
        ВЕРНУТЬ 100;
    )

    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ аргументы_по_умолчанию(а=3, c=1, б=массив(1, массив(2, 3)), q=2, f=массив(2+2*2, (2+2)*2), bool=ИСТИНА ИЛИ ИСТИНА И (ЛОЖЬ), _=по_умолчанию())(
    )
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ функция() (
        ЦИКЛ ОТ 0 ДО 1000 (
            аргументы_по_умолчанию();
        )
    )
    
    ВЫПОЛНИТЬ (
        функция();
    )
    """
}

compiled_cases: dict[str, Compiled] = {}

for name, code in cases.items():
    print(f"Компиляция тест-кейса: {name}")
    compiled_cases[name] = compile_string(code)
    print(f"Тест-кейс успешно скомпилирован: {name}")

results: list[str] = []

print("\nЗапуск тестов...")

for name, code in compiled_cases.items():
    print(f"Запуск тест-кейса: {name}")
    st0 = time.perf_counter()
    run_compiled_code(code)
    st1 = time.perf_counter()
    print(f"Тест-кейс успешно пройден: {name}")

    results.append(f"{name}: {st1 - st0}")

print("\nРезультаты:")
print("\n".join(results))
