import time
from random import randint
from statistics import mean

from src.util.build_tools.compile import Compiled
from src.util.build_tools.starter import compile_string, run_compiled_code

PATH_TO_LIB = "стандартная_библиотека.*"

# Конфигурация тестирования
TEST_RUNS = 5  # Количество запусков каждого теста

cases = {
    "Простой тест":
    """
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ ТЕСТ_0() (
        НАПЕЧАТАТЬ "ТЕСТ0";
    )
    ВЫПОЛНИТЬ (
        ТЕСТ_0();
    )
    """,
    "Поиск суммы":
        f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}

    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ сум() (
        ЗАДАТЬ результат = 0;
        ЗАДАТЬ массив_чисел = массив({", ".join(map(str, range(100)))});
        ЗАДАТЬ длина = длина_массива(массив_чисел);

        ЦИКЛ текущий_индекс ОТ 0 ДО длина-1 (
            результат = (результат + достать_из_массива(массив_чисел, текущий_индекс)) * 2 + 100;
        )

        НАПЕЧАТАТЬ результат;
    )

    ВЫПОЛНИТЬ (
        сум();
    )
    """,
    "Сортировка массива":
        f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}

    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ сортировка_массива(массив_чисел) (
        ЗАДАТЬ длина = длина_массива(массив_чисел);
        ЗАДАТЬ минимальный_индекс = 0;

        ЦИКЛ индекс ОТ 0 ДО длина-1 (
            ! Находим минимальный элемент в оставшейся части массива
            минимальный_индекс = индекс;

            ЦИКЛ внутренний_индекс ОТ индекс+1 ДО длина-1 (
                ЕСЛИ достать_из_массива(массив_чисел, внутренний_индекс) МЕНЬШЕ достать_из_массива(массив_чисел, минимальный_индекс) ТО (
                    минимальный_индекс = внутренний_индекс;
                )
            )
            
            ! Меняем местами найденный минимальный элемент с текущим
            ЕСЛИ минимальный_индекс НЕРАВНО индекс ТО (
                ЗАДАТЬ временная_переменная = достать_из_массива(массив_чисел, индекс);
                изменить_в_массиве(массив_чисел, индекс, достать_из_массива(массив_чисел, минимальный_индекс));
                изменить_в_массиве(массив_чисел, минимальный_индекс, временная_переменная);
            )
        )

        НАПЕЧАТАТЬ массив_чисел;
    )

    ВЫПОЛНИТЬ (
        сортировка_массива(массив({", ".join([str(randint(0, 100)) for _ in range(100)])}));
    )
    """,
    "Быстрая сортировка массива":
        f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ быстрая_сортировка(массив_чисел, левый_индекс, правый_индекс) (
        ЕСЛИ левый_индекс МЕНЬШЕ правый_индекс ТО (
            ЗАДАТЬ опорный_индекс = разделить_массив(массив_чисел, левый_индекс, правый_индекс);
    
            ! Рекурсивно сортируем элементы до и после опорного
            быстрая_сортировка(массив_чисел, левый_индекс, опорный_индекс - 1);
            быстрая_сортировка(массив_чисел, опорный_индекс + 1, правый_индекс);
        )
    )
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ разделить_массив(массив_чисел, левый_индекс, правый_индекс) (
        ЗАДАТЬ опорный_элемент = достать_из_массива(массив_чисел, правый_индекс);
        ЗАДАТЬ индекс_меньшего = левый_индекс - 1;
    
        ЦИКЛ индекс ОТ левый_индекс ДО правый_индекс - 1 (
            ЕСЛИ достать_из_массива(массив_чисел, индекс) МЕНЬШЕ опорный_элемент ТО (
                индекс_меньшего = индекс_меньшего + 1;
    
                ! Меняем местами элементы
                ЗАДАТЬ временная_переменная = достать_из_массива(массив_чисел, индекс_меньшего);
                изменить_в_массиве(массив_чисел, индекс_меньшего, достать_из_массива(массив_чисел, индекс));
                изменить_в_массиве(массив_чисел, индекс, временная_переменная);
            )
        )
    
        ! Меняем местами опорный элемент
        ЗАДАТЬ временная_переменная = достать_из_массива(массив_чисел, индекс_меньшего + 1);
        изменить_в_массиве(массив_чисел, индекс_меньшего + 1, достать_из_массива(массив_чисел, правый_индекс));
        изменить_в_массиве(массив_чисел, правый_индекс, временная_переменная);
    
        ВЕРНУТЬ индекс_меньшего + 1;
    )
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ сортировка_массива(массив_чисел) (
        ЗАДАТЬ длина = длина_массива(массив_чисел);
        ЕСЛИ длина БОЛЬШЕ 0 ТО (
            быстрая_сортировка(массив_чисел, 0, длина - 1);
        )
        НАПЕЧАТАТЬ массив_чисел;
    )
    
    ВЫПОЛНИТЬ (
        сортировка_массива(массив({", ".join([str(randint(0, 100)) for _ in range(100)])}));
    )
    """,
    "Вызов функций с аргументами по умолчанию":
        f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}

    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ по_умолчанию()(
        ВЕРНУТЬ 100;
    )

    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ аргументы_по_умолчанию(а=3, c=1, б=массив(1, массив(2, 3)), q=2, f=массив(2+2*2, (2+2)*2), bool=ИСТИНА ИЛИ ИСТИНА И (ЛОЖЬ), _=по_умолчанию())(
    )

    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ функция() (
        ЦИКЛ ОТ 0 ДО 1000 (
            аргументы_по_умолчанию();
        )
    )

    ВЫПОЛНИТЬ (
        функция();
    )
    """,
    "Вызов функций без аргументов":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}

    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ без_аргументов()(
    )

    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ функция() (
        ЦИКЛ ОТ 0 ДО 1000 (
            без_аргументов();
        )
    )
    ВЫПОЛНИТЬ (
        функция();
    )
    """,
    "Вызов функций с аргументами":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ функция_с_аргументами(а, б, в) (
    )

    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ тест() (
        ЦИКЛ i ОТ 1 ДО 1000 (
            функция_с_аргументами(1, 2, 3);
        )
    )
    
    ВЫПОЛНИТЬ (
        тест();
    )
    """,
    "Рекурсивный вызов":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ факториал(n) (
        ЕСЛИ n МЕНЬШЕ 0 ТО (
            ВЕРНУТЬ "Ошибка: факториал отрицательного числа";
        )
        ЕСЛИ (n РАВНО 0) ИЛИ (n РАВНО 1) ТО (
            ВЕРНУТЬ 1;
        )
        ВЕРНУТЬ n * факториал(n - 1);
    )
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ тест() (
        ЦИКЛ i ОТ 1 ДО 1000 (
            НАПЕЧАТАТЬ факториал(10); ! Должно быть 3628800
        )
        
    )
    
    ВЫПОЛНИТЬ (
        тест();  
    )
    """,
    "Глубоко вложенные вызовы":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ уровень1() ( 
        ВЕРНУТЬ уровень2(); 
    )
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ уровень2() (
        ВЕРНУТЬ уровень3(); 
    )
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ уровень3() (
        ВЕРНУТЬ уровень4(); 
    )
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ уровень4() ( 
        ВЕРНУТЬ уровень5(); 
    )
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ уровень5() ( 
        ВЕРНУТЬ "Достигнут уровень 5"; 
    )
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ тест() (
        НАПЕЧАТАТЬ уровень1(); ! Должно вывести "Достигнут уровень 5"
    )
    
    ВЫПОЛНИТЬ (
        тест();  
    )
    """,
    "Строковые операции":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ тест_строк() (
        ЗАДАТЬ s = "";
        ЦИКЛ i ОТ 1 ДО 1000 (
            s = s + "a";
        )
        НАПЕЧАТАТЬ длина_строки(s); ! Должно быть 1000
    )
    
    ВЫПОЛНИТЬ (
        тест_строк();  
    )
    """,
    "Математические операции":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ тест_математики() (
        ЗАДАТЬ a = 0;
        ЗАДАТЬ b = 0;
        ЗАДАТЬ c = 0;
        
        ЦИКЛ ОТ 0 ДО 1000 (
            a = 2 ^ 10;  ! 1024
            b = корень(100);  ! 10
            c = синус(3.1415926 / 2);  ! ~1
        )

        НАПЕЧАТАТЬ a + b + c; !   Должно быть ~1035
    )
    
    ВЫПОЛНИТЬ (
        тест_математики(); 
    )
    """,
    "Сложные математические выражения":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ тест_математики() (
        ЗАДАТЬ результат = 0;
        
        ЦИКЛ ОТ 0 ДО 1000 (
            результат = (корень(144) + синус(пи()/2)) * косинус(0) ^ 2 + (2+2)*2;
        )
        
        НАПЕЧАТАТЬ результат;  ! Должно быть ~21.0
    )
    
    ВЫПОЛНИТЬ (
        тест_математики();
    )
    """,
    "Базовые математические операции":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
 
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ тест_базовой_математики() (
        ! Проверка основных операций
        ЦИКЛ ОТ 0 ДО 1000 (
            НАПЕЧАТАТЬ корень(25);          ! 5
            НАПЕЧАТАТЬ синус(пи()/2);       ! ~1
            НАПЕЧАТАТЬ косинус(0);          ! 1
            НАПЕЧАТАТЬ округлить(3.75);     ! 4
            НАПЕЧАТАТЬ модуль(-10);         ! 10
            НАПЕЧАТАТЬ 2 ^ 8;               ! 256
            НАПЕЧАТАТЬ экспонента(1);       ! ~2.718
            НАПЕЧАТАТЬ логарифм(100, 10);   ! 2
            НАПЕЧАТАТЬ тангенс(пи()/4);     ! ~1
        )
    )
    
    ВЫПОЛНИТЬ (
        тест_базовой_математики();
    )   
    """,
    "Работа со строками":
    f"""
    ВКЛЮЧИТЬ {PATH_TO_LIB}
    
    ОПРЕДЕЛИТЬ ПРОЦЕДУРУ тест_строк() (
        ЗАДАТЬ s = "             Привет, мир!";
        ЦИКЛ ОТ 0 ДО 1000 (
            НАПЕЧАТАТЬ длина_строки(s);  ! Должно быть 12
            НАПЕЧАТАТЬ убрать_пробелы(s);  
            НАПЕЧАТАТЬ начинается_с("Приветasd", "Привет"); 
            НАПЕЧАТАТЬ заканчивается_на(s, "мир!");
            НАПЕЧАТАТЬ объединить_строки("s1", "s2");
            НАПЕЧАТАТЬ разделить_строку(s, ",");
            НАПЕЧАТАТЬ заменить_в_строке(s, ",", "!!!!!");
            НАПЕЧАТАТЬ найти_в_строке(s, ",");
            НАПЕЧАТАТЬ подстрока(s, найти_в_строке(s, "П"), найти_в_строке(s, ","));
            НАПЕЧАТАТЬ верхний_регистр(s);
            НАПЕЧАТАТЬ нижний_регистр(s);
            НАПЕЧАТАТЬ регулярное_выражение(s, "[а-яА-Я]");
        )
    )
    
    ВЫПОЛНИТЬ (
        тест_строк();
    )
    """
}

compiled_cases: dict[str, Compiled] = {}

# Компиляция тестов
for name, code in cases.items():
    print(f"Компиляция тест-кейса: {name}")
    compiled_cases[name] = compile_string(code)
    print(f"Тест-кейс успешно скомпилирован: {name}")

results: dict[str, list[float]] = {name: [] for name in cases.keys()}

print(f"\nЗапуск тестов (каждый тест будет выполнен {TEST_RUNS} раз)...")
start_all_time = time.perf_counter()

for run in range(1, TEST_RUNS + 1):
    print(f"\nЗапуск #{run}")
    for name, code in compiled_cases.items():
        print(f"  Запуск тест-кейса: {name}")
        st0 = time.perf_counter()
        run_compiled_code(code)
        st1 = time.perf_counter()
        execution_time = st1 - st0
        results[name].append(execution_time)
        print(f"  Тест-кейс завершен: {name} - {execution_time:.6f} сек")

end_all_time = time.perf_counter() - start_all_time

# Вывод результатов
print("\nРезультаты тестирования:")
print(f"{'Название теста':<40} {'Среднее время':<15} {'Минимальное время':<15} {'Максимальное время':<15}")
print("-" * 90)

for name, times in results.items():
    avg_time = mean(times)
    min_time = min(times)
    max_time = max(times)
    print(f"{name:<40} {avg_time:.6f} сек   {min_time:.6f} сек   {max_time:.6f} сек")

print("\nДетальные результаты по каждому запуску:")
for name, times in results.items():
    print(f"\n{name}:")
    for i, t in enumerate(times, 1):
        print(f"  Запуск #{i}: {t:.6f} сек")

print(f"Общее время: {end_all_time}")
